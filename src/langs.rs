use std::ffi::OsStr;
use std::fmt;
use std::fmt::Display;
use std::path::Path;
use std::path::PathBuf;

use crate::color::Color;

#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub enum Language {
	Ada,
	Assembly,
	Astro,
	Bash,
	Batch,
	Bqn,
	Brainfuck,
	C,
	Carbon,
	Clojure,
	CMake,
	Cobol,
	CommonLisp,
	CoffeeScript,
	Crystal,
	CSharp,
	Css,
	Cue,
	Cxx,
	C3,
	D,
	Dart,
	Dhall,
	Dockerfile,
	Elm,
	Elixir,
	Erlang,
	Fortran,
	Fish,
	FSharp,
	Gleam,
	Gn,
	Go,
	Grain,
	GraphQl,
	Gren,
	Hare,
	Haskell,
	Haxe,
	Html,
	Hylo,
	Idris,
	Io,
	Jai,
	Java,
	JavaScript,
	Json,
	Julia,
	Koka,
	Kotlin,
	Llvm,
	Lua,
	Make,
	Markdown,
	Metal,
	Nim,
	Nix,
	NuShell,
	ObjectiveC,
	ObjectiveCxx,
	OCaml,
	Odin,
	Pascal,
	Php,
	Perl,
	PowerShell,
	Prolog,
	PureScript,
	Python,
	R,
	Racket,
	Raku,
	Reason,
	Ren,
	ReScript,
	Ruby,
	Roc,
	Rust,
	Sass,
	Scss,
	Scala,
	Scheme,
	Seafoam,
	Sql,
	Svelte,
	Swift,
	Tcl,
	Terraform,
	Toml,
	TypeScript,
	Unison,
	V,
	Vala,
	Vale,
	VisualBasic,
	Vue,
	WebAssembly,
	Wren,
	Xml,
	Yall,
	Yaml,
	YueScript,
	Zig,
}

impl Language {
	pub fn info(&self) -> LanguageInfo {
		LanguageInfo::from(self)
	}
}

impl Display for Language {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		let info = LanguageInfo::from(self);
		write!(f, "{}", &info.name)
	}
}

impl Language {
	pub fn from_name<S>(name: S) -> Option<Self>
	where
		S: AsRef<str>,
	{
		use Language::*;

		match name.as_ref().to_ascii_lowercase().as_ref() {
			"ada" => Some(Ada),
			"assembly" => Some(Assembly),
			"astro" => Some(Astro),
			"bash" => Some(Bash),
			"batch" => Some(Batch),
			"bqn" => Some(Bqn),
			"brainfuck" => Some(Brainfuck),
			"c" => Some(C),
			"carbon" => Some(Carbon),
			"clojure" => Some(Clojure),
			"cmake" => Some(CMake),
			"cobol" => Some(Cobol),
			"coffeescript" => Some(CoffeeScript),
			"commonlisp" => Some(CommonLisp),
			"crystal" => Some(Crystal),
			"csharp" => Some(CSharp),
			"c3" => Some(C3),
			"c#" => Some(CSharp),
			"css" => Some(Css),
			"cue" => Some(Cue),
			"c++" => Some(Cxx),
			"d" => Some(D),
			"dart" => Some(Dart),
			"dhall" => Some(Dhall),
			"dockerfile" => Some(Dockerfile),
			"elm" => Some(Elm),
			"erlang" => Some(Erlang),
			"elixir" => Some(Elixir),
			"fortran" => Some(Fortran),
			"fish" => Some(Fish),
			"fsharp" => Some(FSharp),
			"f#" => Some(FSharp),
			"gleam" => Some(Gleam),
			"gn" => Some(Gn),
			"go" => Some(Go),
			"graphql" => Some(GraphQl),
			"grain" => Some(Grain),
			"gren" => Some(Gren),
			"hare" => Some(Hare),
			"haskell" => Some(Haskell),
			"haxe" => Some(Haxe),
			"html" => Some(Html),
			"hylo" => Some(Hylo),
			"idris" => Some(Idris),
			"io" => Some(Io),
			"jai" => Some(Jai),
			"java" => Some(Java),
			"julia" => Some(Julia),
			"javascript" => Some(JavaScript),
			"json" => Some(Json),
			"koka" => Some(Koka),
			"kotlin" => Some(Kotlin),
			"llvm" => Some(Llvm),
			"lua" => Some(Lua),
			"objectivec" => Some(ObjectiveC),
			"objective-c" => Some(ObjectiveC),
			"markdown" => Some(Markdown),
			"make" => Some(Make),
			"metal" => Some(Metal),
			"ocaml" => Some(OCaml),
			"objectivec++" => Some(ObjectiveCxx),
			"objective-c++" => Some(ObjectiveCxx),
			"nim" => Some(Nim),
			"nix" => Some(Nix),
			"nushell" => Some(NuShell),
			"odin" => Some(Odin),
			"pascal" => Some(Pascal),
			"php" => Some(Php),
			"perl" => Some(Perl),
			"prolog" => Some(Prolog),
			"powershell" => Some(PowerShell),
			"purescript" => Some(PureScript),
			"python" => Some(Python),
			"r" => Some(R),
			"racket" => Some(Racket),
			"raku" => Some(Raku),
			"reason" => Some(Reason),
			"reasonml" => Some(Reason),
			"ren" => Some(Ren),
			"rescript" => Some(ReScript),
			"roc" => Some(Roc),
			"ruby" => Some(Ruby),
			"rust" => Some(Rust),
			"sass" => Some(Sass),
			"scss" => Some(Scss),
			"scala" => Some(Scala),
			"scmeme" => Some(Scheme),
			"sf" => Some(Seafoam),
			"sql" => Some(Sql),
			"svelte" => Some(Svelte),
			"swift" => Some(Swift),
			"tcl" => Some(Tcl),
			"terraform" => Some(Terraform),
			"toml" => Some(Toml),
			"typescript" => Some(TypeScript),
			"unison" => Some(Unison),
			"v" => Some(V),
			"vala" => Some(Vala),
			"vale" => Some(Vale),
			"visualbasic" => Some(VisualBasic),
			"vue" => Some(Vue),
			"webassembly" => Some(WebAssembly),
			"wren" => Some(Wren),
			"xml" => Some(Xml),
			"yall" => Some(Yall),
			"yaml" => Some(Yaml),
			"yuescript" => Some(YueScript),
			"zig" => Some(Zig),
			_ => None,
		}
	}

	pub fn from_file_name<S>(file_name: S) -> Option<Self>
	where
		S: AsRef<OsStr>,
	{
		use Language::*;

		match file_name.as_ref().to_str()? {
			"Cakefile" => Some(CoffeeScript),
			"CMakeLists.txt" => Some(CMake),
			"Dockerfile" => Some(Dockerfile),
			"Makefile" => Some(Make),
			"Rakefile" => Some(Ruby),
			_ => Path::new(file_name.as_ref())
				.extension()
				.and_then(Language::from_extension),
		}
	}

	pub fn from_extension<S>(ext: S) -> Option<Self>
	where
		S: AsRef<OsStr>,
	{
		use Language::*;

		match ext.as_ref().to_str()?.to_ascii_lowercase().as_ref() {
			"adb" => Some(Ada),
			"ads" => Some(Ada),
			"asm" => Some(Assembly),
			"astro" => Some(Astro),
			"b" => Some(Brainfuck),
			"bat" => Some(Batch),
			"bqn" => Some(Bqn),
			"c" => Some(C),
			"carbon" => Some(Carbon),
			"cbl" => Some(Cobol),
			"cc" => Some(Cxx),
			"cjs" => Some(JavaScript),
			"cl" => Some(CommonLisp),
			"clj" => Some(Clojure),
			"cljc" => Some(Clojure),
			"cljs" => Some(Clojure),
			"cob" => Some(Cobol),
			"coffee" => Some(CoffeeScript),
			"cpp" => Some(Cxx),
			"cpp2" => Some(Cxx),
			"cpy" => Some(Cobol),
			"cr" => Some(Crystal),
			"cs" => Some(CSharp),
			"csproj" => Some(Xml),
			"css" => Some(Css),
			"cts" => Some(TypeScript),
			"cue" => Some(Cue),
			"cxx" => Some(Cxx),
			"c3" => Some(C3),
			"d" => Some(D),
			"dart" => Some(Dart),
			"dhall" => Some(Dhall),
			"elm" => Some(Elm),
			"erl" => Some(Erlang),
			"ex" => Some(Elixir),
			"exs" => Some(Elixir),
			"f" => Some(Fortran),
			"fish" => Some(Fish),
			"for" => Some(Fortran),
			"fs" => Some(FSharp),
			"fsproj" => Some(Xml),
			"f90" => Some(Fortran),
			"f95" => Some(Fortran),
			"f03" => Some(Fortran),
			"gleam" => Some(Gleam),
			"gn" => Some(Gn),
			"go" => Some(Go),
			"gql" => Some(GraphQl),
			"gr" => Some(Grain),
			"gren" => Some(Gren),
			"h" => Some(C),
			"ha" => Some(Hare),
			"hh" => Some(Cxx),
			"hpp" => Some(Cxx),
			"hs" => Some(Haskell),
			"htm" => Some(Html),
			"html" => Some(Html),
			"hx" => Some(Haxe),
			"hxx" => Some(Cxx),
			"idr" => Some(Idris),
			"io" => Some(Io),
			"jai" => Some(Jai),
			"java" => Some(Java),
			"jl" => Some(Julia),
			"js" => Some(JavaScript),
			"json" => Some(Json),
			"jsonc" => Some(Json),
			"jsx" => Some(JavaScript),
			"kk" => Some(Koka),
			"kt" => Some(Kotlin),
			"kts" => Some(Kotlin),
			"l" => Some(CommonLisp),
			"lisp" => Some(CommonLisp),
			"ll" => Some(Llvm),
			"lsp" => Some(CommonLisp),
			"lua" => Some(Lua),
			"m" => Some(ObjectiveC),
			"md" => Some(Markdown),
			"metal" => Some(Metal),
			"mjs" => Some(JavaScript),
			"mk" => Some(Make),
			"ml" => Some(OCaml),
			"mli" => Some(OCaml),
			"mm" => Some(ObjectiveCxx),
			"mts" => Some(TypeScript),
			"nim" => Some(Nim),
			"nix" => Some(Nix),
			"nu" => Some(NuShell),
			"odin" => Some(Odin),
			"pas" => Some(Pascal),
			"php" => Some(Php),
			"pl" => Some(Perl),
			"pm" => Some(Perl),
			"pl6" => Some(Raku),
			"pm6" => Some(Raku),
			"pro" => Some(Prolog),
			"ps1" => Some(PowerShell),
			"purs" => Some(PureScript),
			"py" => Some(Python),
			"p6" => Some(Raku),
			"r" => Some(R),
			"raku" => Some(Raku),
			"rakumod" => Some(Raku),
			"rb" => Some(Ruby),
			"re" => Some(Reason),
			"ren" => Some(Ren),
			"res" => Some(ReScript),
			"rkt" => Some(Racket),
			"roc" => Some(Roc),
			"rs" => Some(Rust),
			"s" => Some(Assembly),
			"sass" => Some(Sass),
			"scss" => Some(Scss),
			"scala" => Some(Scala),
			"scm" => Some(Scheme),
			"sh" => Some(Bash),
			"sql" => Some(Sql),
			"svelte" => Some(Svelte),
			"swift" => Some(Swift),
			"tcl" => Some(Tcl),
			"tf" => Some(Terraform),
			"toml" => Some(Toml),
			"ts" => Some(TypeScript),
			"tsx" => Some(TypeScript),
			"u" => Some(Unison),
			"v" => Some(V),
			"val" => Some(Hylo),
			"vala" => Some(Vala),
			"vale" => Some(Vale),
			"vb" => Some(VisualBasic),
			"vbproj" => Some(Xml),
			"vbs" => Some(VisualBasic),
			"vue" => Some(Vue),
			"wat" => Some(WebAssembly),
			"wren" => Some(Wren),
			"xml" => Some(Xml),
			"yall" => Some(Yall),
			"yaml" => Some(Yaml),
			"yml" => Some(Yaml),
			"yue" => Some(YueScript),
			"zig" => Some(Zig),
			_ => None,
		}
	}
}

#[derive(Clone, Debug)]
pub struct LanguageInfo {
	pub name: String,
	pub color: Option<Color>,
}

macro_rules! info {
	( $n:expr $(,)? ) => {{
		LanguageInfo {
			name: $n.into(),
			color: None,
		}
	}};

	( $n:expr , color: $c:expr $(,)? ) => {{
		LanguageInfo {
			name: $n.into(),
			color: Some($c.into()),
		}
	}};
}

impl LanguageInfo {
	pub fn from(lang: &Language) -> Self {
		use Language::*;

		match lang {
			Ada => info!("Ada", color: 0x02f88c),
			Assembly => info!("Assembly"),
			Astro => info!("Astro", color: 0xa78bfa),
			Bash => info!("Bash", color: [50, 50, 50]),
			Batch => info!("Batch"),
			Bqn => info!("BQN", color: 0x3D6C64),
			Brainfuck => info!("Brainfuck"),
			// C => info!("C", color: [163, 176, 240]),
			C => info!("C", color: [40, 48, 126]),
			Carbon => info!("Carbon"),
			Clojure => info!("Clojure", color: [0, 112, 255]),
			CMake => info!("CMake"),
			Cobol => info!("Cobol", color: [0, 112, 255]),
			CoffeeScript => info!("CoffeeScript", color: 0x3e2723),
			CommonLisp => info!("CommonLisp", color: 0x3fb68b),
			Crystal => info!("Crystal", color: 0x000000),
			CSharp => info!("C#", color: [5, 142, 12]),
			Css => info!("CSS", color: 0x563d7c),
			Cue => info!("Cue"),
			Cxx => info!("C++", color: [25, 65, 122]),
			C3 => info!("C3", color: 0x355beb),
			D => info!("D", color: 0xb03931),
			Dart => info!("Dart", color: 0x40c4ff),
			Dhall => info!("Dhall"),
			Dockerfile => info!("Dockerfile", color: 0x003f8c),
			Elm => info!("Elm", color: 0x60b5cc),
			Elixir => info!("Elixir", color: 0x4e2a8e),
			Erlang => info!("Erlang", color: 0xa2003e),
			Fish => info!("Fish", color: 0x75147c),
			Fortran => info!("Fortran"),
			FSharp => info!("F#", color: 0xb845fc),
			Gleam => info!("Gleam", color: 0xffaff3),
			Gn => info!("gn"),
			Go => info!("Go", color: 0x00add8),
			Grain => info!("Grain", color: [255, 133, 14]),
			GraphQl => info!("GraphQL", color: 0xe10098),
			Gren => info!("Gren", color: 0xff6600),
			Hare => info!("Hare", color: 0x121415),
			Haskell => info!("Haskell", color: 0x6144b3),
			Haxe => info!("Haxe", color: 0xf68712),
			Html => info!("HTML", color: 0xdf6e3c),
			Hylo => info!("Hylo", color: [0, 119, 179]),
			Idris => info!("Idris", color: 0xc74350),
			Io => info!("Io", color: 0xa9188d),
			Jai => info!("Jai"),
			// Java => info!("Java", color: [205, 112, 42]),
			Java => info!("Java", color: [205, 55, 47]),
			JavaScript => info!("JavaScript", color: 0xf1e05a),
			Json => info!("JSON"),
			Julia => info!("Julia", color: 0xa270ba),
			Koka => info!("Koka"),
			Kotlin => info!("Kotlin", color: 0xa97bff),
			Llvm => info!("LLVM IR"),
			Lua => info!("Lua", color: 0x000077),
			Make => info!("Make"),
			Markdown => info!("Markdown"),
			Metal => info!("Metal", color: 0xca495d),
			Nim => info!("Nim", color: 0xffc200),
			Nix => info!("Nix", color: 0x5773b8),
			NuShell => info!("NuShell", color: 0x3aa675),
			ObjectiveC => info!("Objective-C"),
			ObjectiveCxx => info!("Objective-C++"),
			OCaml => info!("OCaml", color: 0xee6a1a),
			Odin => info!("Odin", color: 0x3882d2),
			Pascal => info!("Pascal"),
			Perl => info!("Perl", color: 0x0073a1),
			Php => info!("PHP", color: 0x4f5d95),
			PowerShell => info!("PowerShell"),
			Prolog => info!("Prolog"),
			PureScript => info!("PureScript"),
			Python => info!("Python", color: 0x3776ab),
			R => info!("R", color: 0x198ce7),
			Racket => info!("Racket"),
			Raku => info!("Raku", color: 0xd0dd2b),
			Reason => info!("Reason", color: 0xdb4d3f),
			Ren => info!("Ren", color: 0xdd5e36),
			ReScript => info!("ReScript", color: 0xD55454),
			Ruby => info!("Ruby", color: 0xcc342d),
			Roc => info!("Roc", color: 0x7c59dd),
			Rust => info!("Rust", color: 0xa72145),
			Sass => info!("Sass", color: 0xcf649a),
			Scss => info!("SCSS", color: 0xc6538c),
			Scala => info!("Scala", color: 0xc6422f),
			Scheme => info!("Scheme"),
			Seafoam => info!("Seafoam", color: 0x90eada),
			Sql => info!("SQL", color: 0x336790),
			Svelte => info!("Svelte", color: 0xe44d26),
			Swift => info!("Swift", color: 0xf05138),
			Tcl => info!("Tcl"),
			Terraform => info!("Terraform", color: 0x844fba),
			Toml => info!("TOML"),
			TypeScript => info!("TypeScript", color: 0x3178c6),
			Unison => info!("Unison", color: [118, 207, 143]),
			V => info!("V"),
			Vala => info!("Vala", color: 0x7239b3),
			Vale => info!("Vale"),
			VisualBasic => info!("Visual Basic"),
			Vue => info!("Vue", color: 0x41b883),
			WebAssembly => info!("WebAssembly", color: 0x654ff0),
			Wren => info!("Wren", color: 0x383838),
			Xml => info!("XML"),
			Yall => info!("Y'all", color: 0xff8f77),
			Yaml => info!("YAML"),
			YueScript => info!("YueScript", color: 0xb7ae8f),
			Zig => info!("Zig", color: 0xeba842),
		}
	}
}

#[derive(Clone, Debug)]
pub struct LanguageSummary {
	pub language: Language,
	pub lines: usize,
	pub blank_lines: usize,
	pub files: Vec<PathBuf>,
}

impl LanguageSummary {
	pub fn from(language: Language) -> Self {
		Self {
			language,
			lines: 0,
			blank_lines: 0,
			files: vec![],
		}
	}
}

#[cfg(test)]
mod tests {
	use super::*;
	use Language::*;

	#[test]
	fn language_from_file_name() {
		let check = |inner| Language::from_file_name(OsStr::new(inner));

		assert_eq!(check(""), None);
		assert_eq!(check("CMakeLists.txt"), Some(CMake));
		assert_eq!(check("main.rs"), Some(Rust));
		assert_eq!(check("Makefile"), Some(Make));
		assert_eq!(check("NotCMake.txt"), None);
		assert_eq!(check("README.md"), Some(Markdown));
		assert_eq!(check("main.zig"), Some(Zig));
	}
}
